{"componentChunkName":"component---src-templates-blog-post-index-jsx","path":"/GoogleIO-2022/","result":{"data":{"site":{"siteMetadata":{"title":"QDS"}},"markdownRemark":{"id":"7456fb33-ca3e-5c68-b097-ac5f0d2a54cf","excerpt":"Priority Hints 1.script标签的defer和async属性可在下载的时候不阻碍HTML Parsing。均为为异步加载，和优先级没有关系。defer是在Parsing完成后执行,async是在下载完成后执行。依赖DOM的脚本不能使用async属性。   2.link标签的preload…","html":"<h2>Priority Hints</h2>\n<p>1.script标签的defer和async属性可在下载的时候不阻碍HTML Parsing。均为为异步加载，和优先级没有关系。defer是在Parsing完成后执行,async是在下载完成后执行。依赖DOM的脚本不能使用async属性。  </p>\n<p>2.link标签的preload可以使浏览器预先获取和缓存对应资源<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types/preload\">(mdn=>)</a>。  </p>\n<p>3.<strong>fetchpriority属性可以设置资源的优先级，用于link,img,script,iframe标签。有high,low,auto三种值选择，同时fetch请求也可指定priority。目前只有chrome支持。</strong>  </p>\n<p>4.img标签中可以使用loading=“lazy”属性，可以延迟图片的加载。包含auto、lazy、eager三种值，auto是默认值，lazy是延迟加载，eager是立即加载。但在何时进行加载需要根据浏览器的实现而定。  </p>\n<blockquote>\n<p><a href=\"https://web.dev/priority-hints/\">原始文章</a><br>\n<a href=\"https://www.youtube.com/watch?v=5b4YcLB4DVI&#x26;t=561s\">GooleIO 视频</a></p>\n</blockquote>\n<hr>\n<h2>Deep-copy</h2>\n<p>1.可以不用在使用JSON.parse(JSON.stringify(obj))，进行深拷贝。  </p>\n<p>2.使用JSON的方式容易出现错误的情况，比如：  </p>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"lucario\" >\n          <code slot=\"code\">const obj = {\n  date: new Date\n}\n\nobj.date.getFullYear() // 2021\n\nconst temp = JSON.parse(JSON.stringify(obj))\n\ntemp.date.getFullYear() // TypeError: temp.date.getFullYear is not a function</code>\n        </deckgo-highlight-code>\n      \n<p>时间对象会变成时间字符串，所以会出现错误。  </p>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"lucario\" >\n          <code slot=\"code\">const arr = [1]\narr.push(arr)\n\nJSON.parse(JSON.stringify(arr)) // VM411:1 Uncaught TypeError: Converting circular structure to JSON</code>\n        </deckgo-highlight-code>\n      \n<p>出现了循环引用。<br>\n3.关于structuredClone<br>\n详情查看<a href=\"https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone\">mdn=></a></p>\n<h2>Cascade layers</h2>\n<p>css样式应用覆盖规则为:  </p>\n<blockquote>\n<p>!important > 内联style > #id > .class > 标签</p>\n</blockquote>\n<p>使用@layer属性可以设置css样式的层级。对解决样式冲突问题很有帮助，但目前并没有大规模使用起来。目前开发最多的时候还是使用的less或sass的nest解决。</p>","frontmatter":{"title":"GoogleIO-2022","date":"May 14, 2022","description":"Hello World"}}},"pageContext":{"slug":"/GoogleIO-2022/","previous":{"id":"4add07fe-d8b2-5cb8-acb2-5de5f6d35a00","frontmatter":{"title":"deep clone(转载)","tags":["javascript"],"date":"2022年01月04日"},"fields":{"slug":"/deep-clone/"},"excerpt":"deep clone 文中介绍了三种deep clone的方法，可以比较好的解决只使用JSON.parse(JSON.stringify(sourceObj))出现的循环引用的问题。也希望structuredClone()可以被早日支持。\nhttps://www.catagec…"},"next":{"id":"a3070ca3-b068-5c41-aba3-b1d152ac32c5","frontmatter":{"title":"Pipe Operation","tags":["web"],"date":"2022年05月17日"},"fields":{"slug":"/pipe-operation/"},"excerpt":"js的通道运算符目前到达第二提案，对于嵌套语法有点简化效果。采用的是meta的hack语言的pipe语法，对await的支持度较好。 参考：https://github.com/tc39/proposal-pipeline-operator"}}}}