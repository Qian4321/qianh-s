{"componentChunkName":"component---src-templates-blog-post-index-jsx","path":"/clipping-Layer/","result":{"data":{"site":{"siteMetadata":{"title":"QDS"}},"markdownRemark":{"id":"8e32032a-7c6f-598c-b0f1-f3b4406f6e14","excerpt":"在平时的gis开发常常会遇到做地图的遮罩层。有原生的图层数据的话可以直接在gis桌面程序中提取出需要展示的区域。但一些不太方便的图层可以直接使用openlayer提供的api进行遮罩层的开发。经过不同的实验提取出了三种不同的方式来实现遮罩层。\n 使用LinearRing 主要思路 使用LinearRing…","html":"<p>在平时的gis开发常常会遇到做地图的遮罩层。有原生的图层数据的话可以直接在gis桌面程序中提取出需要展示的区域。但一些不太方便的图层可以直接使用openlayer提供的api进行遮罩层的开发。经过不同的实验提取出了三种不同的方式来实现遮罩层。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/22c86/%E9%81%AE%E7%BD%A9%E5%9B%BE.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACHklEQVQ4y31Uy3LaQBDk/z/LTjnJJUX55rINelhISPveFRw7PSPAik3lMLUwzPZ298ywKfMJ9yKX+U7uhBA8YgyIKS01jLyKzf/A5Ey5aMSYGATzFiVb5GSZz9/ube6BXQGDFwDD08GZESUZpOAIJmE0pw+m/MlwzWYdkhMG3jpER1ZkNGePHPndGAx7siTTGBm0Ic+L/M0VbD6dv8tWyZkMeTkYHNoGbjoiWoOpc8pWHpqOzKWi924MfYgIMd0YTuMEZw9kNCE5yjtOaPaVyszZwfTC3CnjcRgImC+A86zd6w8HeD+p2cFO6NsWfbNDtgMy89F6JHZX/JTG9G8BST6TuXp4wVHJgh7FbD/yVZqfRY5HIDM/GfRdQ3bvCpCC+CngFpYq7HiEY12IcWFYLsiBLAI7asmkqWpU+52CRh/Q1h2q1wrnEuEpua52mIYDfv/6ie32D7xIL2sPywJa5jNlexYYBQ8srHbvBGwQjONZYehaspYRoo9mYO2oFtwA14MsMxXYQemcSCr0R+Ywk2n3UePx8QFvL68E5++0J+tvtIV3ci5ryRdA+hAoSWQd+w7j2KtvMshLA7x6qLNIFTIBYpWs4TJuqznUkAYRtK1rPP14wPPzlo9Q2odDv5PhTRwbq81KiV2mzPXO5/IFUNeNLDzHRmREx9PJJkR9/foHIdZ8Av27XSsPl8Yk0k8la4OWHU3KfF33de/X6/sX1eh2Nqw+sF0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"enter description here\"\n        title=\"enter description here\"\n        src=\"/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/fcda8/%E9%81%AE%E7%BD%A9%E5%9B%BE.png\"\n        srcset=\"/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/12f09/%E9%81%AE%E7%BD%A9%E5%9B%BE.png 148w,\n/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/e4a3f/%E9%81%AE%E7%BD%A9%E5%9B%BE.png 295w,\n/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/fcda8/%E9%81%AE%E7%BD%A9%E5%9B%BE.png 590w,\n/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/efc66/%E9%81%AE%E7%BD%A9%E5%9B%BE.png 885w,\n/Charging/static/b4b7d177e6f6a29c695c574e925e3a56/22c86/%E9%81%AE%E7%BD%A9%E5%9B%BE.png 1143w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<hr>\n<h2>使用LinearRing</h2>\n<h3>主要思路</h3>\n<p>使用LinearRing可以实现类似环的效果，那么把比如本文使用的贵州的边界线数据来生成一个LinearRing就可以实现遮罩层。但是LinearRing是不能单独存在的，需要创建一个polygon，并使用appendLinearRing这个方法把LinearRing添加进去。而创建的polygon则可以是直接使用[-90,90],[-180,180]这样的extent来生成。</p>\n<h3>主要代码</h3>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"lucario\" >\n          <code slot=\"code\">import {Map, View} from &#39;ol&#39;;\nimport {Tile as TileLayer, Image as ImageLayer,Vector as VectorLayer} from &#39;ol/layer&#39;;\nimport {OSM, XYZ, ImageStatic, ImageCanvas,Vector as VectorSource } from &#39;ol/source&#39;;\nimport {getVectorContext} from &#39;ol/render&#39;;\nimport {transform, getTransform} from &#39;ol/proj&#39;;\nimport GeoJSON from &#39;ol/format/GeoJSON&#39;;\nimport {Polygon, LinearRing} from &#39;ol/geom&#39;;\nimport {fromExtent} from &#39;ol/geom/Polygon&#39;;\nimport Feature from &#39;ol/Feature&#39;;\nimport {Circle as CircleStyle, Fill, RegularShape, Stroke, Style, Text} from &#39;ol/style&#39;;\n\n\nfunction erase(geom) {\n\t// const extent = [-180,-90,180,90];\n\tconst Max=transform([-180,-90], &#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;);\n\tconst Min=transform([180,90], &#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;);\n\tconst extent = [Max[0],Max[1],Min[1],Min[1]];\n\tconst polygonRing = fromExtent(extent);\n\tgeom.applyTransform(getTransform(&#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;));\n\tconst coords = geom.getCoordinates();\n\tcoords.forEach(coord =&gt;{ \n\t\tconst linearRing = new LinearRing(coord?.[0]);\n\t\tpolygonRing.appendLinearRing(linearRing);\n\t})\n\treturn polygonRing;\n}\n\nfunction addconver(converLayer，data) {\n\tconst fts = new GeoJSON().readFeatures(data);\n\tconst ft = fts?.[0];\n\tconst converGeom = this.erase(ft.getGeometry());\n\tconst convertFt = new Feature({\n\t\tgeometry: converGeom\n\t});\n\tconverLayer.getSource().addFeature(convertFt);\n}</code>\n        </deckgo-highlight-code>\n      \n<h3>代码解析</h3>\n<p>在本文档中使用的是geojson数据。在addconver函数中对geojson数据进行解析(可以将geojson数据后缀名改为.json并直接import),解析出贵州的边框数据后在erase函数中生成linearing并添加到覆盖整个图的polygon中。最后将生成的layer添加到map对象中即可。尤其要注意投影的变换。</p>\n<h2>使用canvas</h2>\n<h3>主要思路</h3>\n<p>借助openlayers提供的ImageCanvasSource 来添加canvas图层,数据源依旧采用的是贵州geojson文件。添加canvas后利用geojson解析出的边界坐标点使用canvas的api生成一个面，并使用canvas的’destination-out’来实现中空的一个效果。</p>\n<h3>主要代码</h3>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"lucario\" >\n          <code slot=\"code\">function render(geo_data){\n\tconst fts = new GeoJSON().readFeatures(geo_data);\n\tconst ft = fts?.[0];\n\tconst coords = ft.getGeometry().getCoordinates();\n\tconst data = coords?.[0]?.[0];\n\t//参数1:extent array 左下角投影坐标与右上角投影坐标\n\t//参数2:resolution 要生产图像的分辨率\n\t//参数3:设备像素比\n\t//参数4:图像实际大小\n\t//参数5:投影\n\treturn function(extent, resolution, pixelRatio, size, projection){\n\t //每次的范围变动都会引起重绘，从而触发该回调函数，\n\t\tconst [width, height] = size; //画布尺寸\n\t\tconst [left, bottom, right, top] = extent; //坐标投影\n\t\tconst xScale = width / (right - left); //画布尺寸与坐标投影比\n\t\tconst yScale = height / (top - bottom);\n\t\tconst transform = getTransform(&#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;);\n\t\tconst canvas=document.createElement(&#39;canvas&#39;);\n\t\tcanvas.width=width;\n\t\tcanvas.height=height;\n\t\tconst ctx = canvas.getContext(&#39;2d&#39;);\n\t\tctx.fillStyle = &quot;rgba(255,255,255,1)&quot;;\n\t\tctx.fillRect(0,0,width,height);\n\t\tctx.globalCompositeOperation = &#39;destination-out&#39;;\n\t\tctx.beginPath();\n\t\tdata.forEach((coor,index)=&gt;{\n\t\t\tconst [lon,lat] = transform(coor);\n\t\t\tconst x = (lon - left) * xScale; //转换成手机次尺寸的xy\n\t\t\tconst y = (top - lat) * yScale;\n\t\t\tindex===0?ctx.moveTo(x, y):1;\n\t\t\tctx.lineTo(x,y);\n\t\t})\n\t\t// ctx.strokeStyle = &#39;rgba(0,0,0,0.5)&#39;;\n\t\tctx.fill();\t\t\t\t\t\n\t\t// ctx.restore();\n\t\t// ctx.fill();\n\t\treturn canvas;\n\t}\n}\n\nconst imageCanvas=new ImageCanvas({\n\t//创建回调函数如下\n\t//data为geojson\n\tcanvasFunction:render(data), \n});\nconst imageLayer=new ImageLayer({\n\tsource:imageCanvas\n});</code>\n        </deckgo-highlight-code>\n      \n<h3>代码解析</h3>\n<p>上面render函数中的坐标转canvas坐标是在网上找的，代码的思路还是很清晰的，只需要注意ctx.globalCompositeOperation = ‘destination-out’;</p>\n<h2>使用图层事件和canvas</h2>\n<p>这种方式也是使用canvas和’destination-out’，但是使用的是openlayer自带的api,使用起来会简单和方便许多，就是第二种方式的进化版。使用图层的’postrender’事件，在图层加载完成之后获取上下文并添加。</p>\n<h3>主要代码</h3>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"lucario\" >\n          <code slot=\"code\">function addPolyon(converLayer,geo_data){\n\tconst fts = new GeoJSON().readFeatures(geo_data);\n\tconst ft = fts?.[0];\n\tft.getGeometry().applyTransform(getTransform(&#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;))\n\tconverLayer.getSource().addFeature(ft);\n\treturn converLayer;\n}\n//获取图层\nconst _layer = map.getLayers().getArray()?.[1]；\nconst newcliplayer = addPolyon(clipLayer,data);\n_layer.on(&#39;postrender&#39;, e=&gt; {\n\te.context.globalCompositeOperation = &#39;destination-in&#39;;\n\tconst vectorContext = getVectorContext(e);\n\tnewcliplayer.getSource().forEachFeature(feature=&gt;{\n\t\tvectorContext.drawFeature(feature, style);\n\t});\n\te.context.globalCompositeOperation = &#39;source-over&#39;;\n});</code>\n        </deckgo-highlight-code>\n      \n<h2>总结</h2>\n<p>使用第三种方式无论是在性能还是代码量来说都是优势，第三种也是ol官方推荐的一种。</p>","frontmatter":{"title":"openlayers实现遮罩的三种方式","date":"June 04, 2020","description":"Hello World"}}},"pageContext":{"slug":"/clipping-Layer/","previous":{"id":"9d1283b9-0b7c-5a3c-9755-db3354f82636","frontmatter":{"title":"学习插值(一)","tags":["gis","meteoinfolab","python","interpolate"],"date":"2020年06月04日"},"fields":{"slug":"/grid-interpolate(1)/"},"excerpt":"关于MeteoInfoLab MeotoInfoLab对于处理气象相关的工作是十分有用且高效的。MeotoInfoLab是使用的jython脚本进行开发，是一个好消息但仔细想想也很难让人接受。可以使用基本Python3的语法但无法使用丰富的cpython包，但也MatLab…"},"next":{"id":"c314ad4b-6116-5925-a5b5-2cbb9d473f4a","frontmatter":{"title":"uni-app使用openlayers","tags":["uni-app","openlayers","gis"],"date":"2020年06月25日"},"fields":{"slug":"/uniapp-openlayers/"},"excerpt":"1.概要 uniapp在提供了强大的多端转换功能的同时，也会极大的限制用户的操作并且为用户提供大量的bug。但对于节约成本和快速上线的app可以还是值得使用的。 2.使用openlayers 在使用openlayers的时候，和在一般的vue框架中使用没有太大的差别。但是uni…"}}}}