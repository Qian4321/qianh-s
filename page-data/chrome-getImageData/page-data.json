{"componentChunkName":"component---src-templates-blog-post-index-jsx","path":"/chrome-getImageData/","result":{"data":{"site":{"siteMetadata":{"title":"QDS"}},"markdownRemark":{"id":"52f2caad-2f77-542d-a86a-6a6564d679af","excerpt":"问题 最近在实现一个鼠标滑动读取ol图层原始RGB颜色的功能。根据ol的示例，采取了监听图层的postrender事件，在事件对象中获取到了canvas context。在context上使用getIamgeData()函数时，在移动地图时会出现明显的卡顿现象。参考的ol示例如下:,参考的stackoverflow…","html":"<h2>问题</h2>\n<p>最近在实现一个鼠标滑动读取ol图层原始RGB颜色的功能。根据ol的示例，采取了监听图层的postrender事件，在事件对象中获取到了canvas context。在context上使用getIamgeData()函数时，在移动地图时会出现明显的卡顿现象。参考的<a href=\"https://openlayers.org/en/latest/examples/layer-spy.html\">ol示例如下:</a>,参考的<a href=\"https://stackoverflow.com/questions/35081751/openlayers-get-pixel-color-from-image-layer\">stackoverflow帖子</a>。</p>\n<p>相同的代码在firefox上运行是很流畅的，所以可以证明是chrome存在一定的性能问题。关于这个问题可以从下面这个帖子中探知一二，<a href=\"https://news.ycombinator.com/item?id=22267547%E3%80%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%9B%BE%E7%89%87%E5%AF%B9%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E9%9D%9E%E5%B8%B8%E5%85%B7%E4%BD%93%E3%80%82\">https://news.ycombinator.com/item?id=22267547。下面的图片对问题描述非常具体。</a>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.13513513513513%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQoz2VR2XKEMAzj/z+t02O3geWGAAk3FPZ+cyPDZLbTB42Mk0i2cOa5IaVS0jpj7rpqR7ljq/tecb2uPd1us8X1Otn6fv8hp20LOhzeSIh3Eu4ned4XwzW17x+5FuLDchS5JGVEZZkwZ1lARREzw9ipa8kX8TgMBR9IGVKeB/bSPDU0DIqmqaZx1Gbaynxr7mHyjStz3pCDMdHAykBd59Q0kmC0LB1dLiOv9bra47HQ87n+A/pGcGEXrTehti3ZDXlhIpht0+i9Vn9MXgEzB6pYEWsHwbfJSFAce5wVIgCjh/Wravt5yA5AdkUR2YgwFAtizTT1DU6MJDkZAZ8ZwFmSeLtAbB6HLAhWKrMZns8D/QKXSgHyh9fM0wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"question\"\n        title=\"question\"\n        src=\"/Charging/static/429e97dcac881bda1789a039584dfe00/fcda8/hackerNews.png\"\n        srcset=\"/Charging/static/429e97dcac881bda1789a039584dfe00/12f09/hackerNews.png 148w,\n/Charging/static/429e97dcac881bda1789a039584dfe00/e4a3f/hackerNews.png 295w,\n/Charging/static/429e97dcac881bda1789a039584dfe00/fcda8/hackerNews.png 590w,\n/Charging/static/429e97dcac881bda1789a039584dfe00/efc66/hackerNews.png 885w,\n/Charging/static/429e97dcac881bda1789a039584dfe00/c83ae/hackerNews.png 1180w,\n/Charging/static/429e97dcac881bda1789a039584dfe00/73dae/hackerNews.png 2122w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2>解决方案</h2>\n<h3>1.拖拽跳过getImageData</h3>\n<p>在拖拽时不触发getImageData()方法。实验结果：只要开始触发过getImageData方法，即使后面在拖拽时不触发getImageData()方法，页面也会有卡顿，通过Performance查看是paint时间究极长的缘故。但只要重头到尾不触发getIamgeData(),就会很流畅。所以方案不通过，而且都多了一个疑问…</p>\n<h3>2.使用forEachLayerAtPixel()</h3>\n<p>原来针对获取值这个操作,ol中有专门的方法进行操作，具体的使用方式很简单而且页面不会卡顿，也有开源贡献者对getImageData()进行了专门的优化。详见：<a href=\"https://github.com/openlayers/openlayers/issues/10597\">https://github.com/openlayers/openlayers/issues/10597</a></p>\n<h3>3.直接copy第二种方法中的优化</h3>\n<h3>4.使用web worker</h3>\n<h2>最后</h2>\n<p>后面两种方法我本人并没有实践，只是在解决问题时提出的提前构想，因为第二种就很完美了，所以也没必要搞了。第一次适配chrome也是别样的感受。</p>","frontmatter":{"title":"chrome使用getImageData耗时","date":"March 13, 2021","description":"Hello World"}}},"pageContext":{"slug":"/chrome-getImageData/","previous":{"id":"f117b5a9-787f-50fa-a314-6370b8630b31","frontmatter":{"title":"[转载]github新推出的个人简介readme.md","tags":["github","profile","reprint"],"date":"2020年07月22日"},"fields":{"slug":"/github-readme/"},"excerpt":"github新推出了一个自我介绍的readme.md,可以使用所有markdown的语法来进行自我介绍。我在md中加载了一张图片。关于如何制作可以参考这篇blog。"},"next":null}}}